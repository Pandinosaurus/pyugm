## 1 July 2014
Maybe concentrate on getting a discrete bayesian network going first.
Factor out the update ordering.
Add gaussian priors [rather dirichlet priors?] - variable and conditional. (Variational/expectation update?)
Add plates - update order should take this into account.
Plates for dynamic models.
Clusters?

## 3 July 2014
Looks like I'm rather going with un-normalised models first.
Gaussian prior.
Factors should now be parametrised - add place where parameter variables can be added to a factor.
Use BFGS to find MAP
Then approximate posterior with Laplace approximation using Hessian returned by BFGS.

## 14 September 2014
Running into numerical problems - time to factor out the normalising constant.
This will complicate testing - for now replace existing data tests with data * constant.
For new tests use accessor methods.
Wondering about architecture - should only inplace updates be allowed?

## 17 September 2014
Example HMM.

## 27 September 2014
Optimise for speed. - Numba looks like it is working. Add Numba update function.
Flooding protocol is slow - build distribute/collect protocol for trees.

## 11 October 2014
Document as clique templates (from Sutton and McCallum's tutorial)

    def reset(self):
        self._to_visit = set()
        self._visited_factors = set()
        for sub_graph in self._model.disconnected_subgraphs:  # Roots
            root_factor = list(sub_graph)[0]
            self._visited_factors.add(root_factor)
            for edge in self._edges:
                if edge[0] == root_factor:
                    self._to_visit.add(edge[1])
                elif edge[1] == root_factor:
                    self._to_visit.add(edge[0])
        self._forward_edges = []
        self._direction = 'distribute'
        self.current_iteration_delta = 0.0
        self.total_iterations = 0

    def next_edge(self, last_update_change):
        """ Get the next edge to update """
        self.current_iteration_delta += last_update_change
        if self._direction == 'distribute':
            if len(self._to_visit) > 0:
                next_factor = self._to_visit.pop()
                for edge in self._edges:
                    if edge[0] == next_factor and edge[1] in self._visited_factors:
                        next_edge = (edge[1], edge[0])
                        self._visited_factors.add(next_factor)
                    elif edge[1] == next_factor and edge[0] in self._visited_factors:
                        next_edge = edge
                        self._visited_factors.add(next_factor)
                    elif edge[0] == next_factor and edge[1] not in self._visited_factors:
                        self._to_visit.add(edge[1])
                    elif edge[1] == next_factor and edge[0] not in self._visited_factors:
                        self._to_visit.add(edge[0])
                self._forward_edges.append(next_edge)
            else:
                self._direction = 'collect'
        if self._direction == 'collect':
            next_edge = None
            if len(self._forward_edges) > 0:
                next_edge_reversed = self._forward_edges.pop()
                next_edge = (next_edge_reversed[1], next_edge_reversed[0])
            elif self.total_iterations == 0:
                self.reset()
                self.total_iterations = 1
                next_edge = self.next_edge(last_update_change)
        return next_edge
